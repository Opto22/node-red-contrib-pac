import request = require('request');
import promise = require('bluebird');
import http = require('http');
import https = require('https');
import fs = require('fs');

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class ControllerResponse
{
    "controllerType": string;
    "firmwareVersion": string;
    "firmwareDate": string;
    "firmwareTime": string;
    "mac1": string;
    "mac2": string;
    "upTimeSeconds": number;
}

export class DigitalPointStateObject
{
    /**
    * State of a digital point (true = on, false = off)
    */
    "value": boolean;
}

export class DigitalPointStateVar
{
    /**
    * Name of the tag (strategy variable, i/o point, etc.)
    */
    "name": string;
    /**
    * State of a digital point (true = on, false = off)
    */
    "value": boolean;
}

export class ErrorResponse400BadAdminOrValue
{
    /**
    * Details: ** -1 ** Invalid or no strategy. Use PAC Control to download strategy logic. ** -3 ** Buffer overrun or invalid length. The number or range of table indicies you specified exceeds elements in the PAC Control table. ** -8 ** Invalid data. Check format of data written. Compare to what's read for the same endpoint. ** -12 ** You've passed a table index that is less than zero or greater than the length of the table minus 1. ** -13 ** The value you passed to write is outside of the valid range for the PAC Control data type you're writing to. For example, if you specified the value 999999999999999 for an integer32 (since integer32 data types must be in the range: -2147483648 to 2147483647). ** -20 ** The controller is busy with another task, for example, downloading a new strategy. Try again later. ** -23 ** The string you passed is longer than the width of PAC Control string variable or table element you're writing to. ** -36 ** Endpoint is not defined. ** -109 ** Attempting to write without write permissions. Check /admin/keys settings. ** -13019 ** Invalid endpoint. Check syntax of the URL (e.g. did you use 'ev' instead of 'eu'). ** 400 ** Before using the API on this device, you must first change the default user name and password via the URL /admin/keys. Use the default User Name: 'admin' and Password: 'password' to log ininitially.
    */
    "errorCode": number;
    "message": string;
}

export class ErrorResponse401BadKeyForBasicAuth
{
    /**
    * Details: ** -104 ** Invalid key ID/value in HTTP header. Before using the API on this device, you must create at least one key ID/value via the URL /admin/keys. Then use one of those in your HTTP header for Basic Authentication.
    */
    "errorCode": number;
    "message": string;
}

export class ErrorResponse404NotFound
{
    /**
    * Details: ** -29 ** The tag (variable, table, timer, I/O point, etc.) you requested exists on the controller but does not match the data type for this endpoint. ** -28 ** The tag (variable, table, timer, I/O point, etc.) does not currently exist on the controller. Check the tag name and the controller's status. ** 404 ** Endpoint does not exist. Check URL.
    */
    "errorCode": number;
    "message": string;
}

export class FloatValueObject
{
    /**
    * Value of the float variable
    */
    "value": number;
}

export class FloatVar
{
    /**
    * Name of the tag (strategy variable, i/o point, etc.)
    */
    "name": string;
    /**
    * Value of the float variable
    */
    "value": number;
}

export class Int32ValueObject
{
    /**
    * Value of the integer32 variable
    */
    "value": number;
}

export class Int32Var
{
    /**
    * Name of the tag (strategy variable, i/o point, etc.)
    */
    "name": string;
    /**
    * Value of the integer32 variable
    */
    "value": number;
}

export class Int64StringValueObject
{
    /**
    * Value of the integer64 variable expressed as decimal string, e.g. \"34359738367\"
    */
    "value": string;
}

export class Int64ValueObject
{
    /**
    * Value of the integer64 variable
    */
    "value": number;
}

export class Int64Var
{
    /**
    * Name of the tag (strategy variable, i/o point, etc.)
    */
    "name": string;
    /**
    * Value of the integer64 variable
    */
    "value": number;
}

export class Int64VarAsString
{
    /**
    * Name of the tag (strategy variable, i/o point, etc.)
    */
    "name": string;
    /**
    * Value of the integer64 variable expressed as a decimal string, E.g. \"34359738367\"
    */
    "value": string;
}

export class StrategyResponse
{
    "strategyName": string;
    "date": string;
    "time": string;
    "crc": string;
    "runningCharts": number;
}

export class StringValueObject
{
    /**
    * The value of a string; string width (max length) for each string variable is defined in the strategy
    */
    "value": string;
}

export class StringVar
{
    /**
    * Name of the tag (strategy variable, i/o point, etc.)
    */
    "name": string;
    /**
    * The value of a string; string width (max length) for each string variable is defined in the strategy
    */
    "value": string;
}

export class TableDef
{
    /**
    * Name of the tag (strategy variable, i/o point, etc.)
    */
    "name": string;
    /**
    * Number of elements contained in this table
    */
    "length": number;
}


interface Authentication
{
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

class HttpBasicAuth implements Authentication
{
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void
    {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

class ApiKeyAuth implements Authentication
{
    public apiKey: string;

    constructor(private location: string, private paramName: string)
    {
    }

    applyToRequest(requestOptions: request.Options): void
    {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

class OAuth implements Authentication
{
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void
    {
        requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
}

class VoidAuth implements Authentication
{
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void
    {
        // Do nothing
    }
}

export enum AllApiApiKeys
{
}

export class AllApi
{
    protected basePath = 'http://restpac.groov.com/api/v1';
    protected defaultHeaders: any = {};

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string)
    {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    public setApiKey(key: AllApiApiKeys, value: string)
    {
        this.authentications[AllApiApiKeys[key]].apiKey = value;
    }

    set username(username: string)
    {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string)
    {
        this.authentications.basicAuth.password = password;
    }
    private extendObj<T1, T2>(objA: T1, objB: T2)
    {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return <T1 & T2>objA;
    }
    /**
     * 
     * Reads the value in engineering units (EU) of the specified analog input
     * @param ioName Name of the analog input point to read
     */
    public readAnalogInputEu(ioName: string): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/analogInputs/{ioName}/eu'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is set
        if (!ioName) {
            throw new Error('Missing required parameter ioName when calling readAnalogInputEu');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: FloatValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name and engineering units (EU) for all analog input points in the strategy
     */
    public readAnalogInputs(): Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/analogInputs';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<FloatVar>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Reads the value in engineering units (EU) of the specified analog output
     * @param ioName Name of analog output point to read
     */
    public readAnalogOutputEu(ioName: string): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/analogOutputs/{ioName}/eu'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is set
        if (!ioName) {
            throw new Error('Missing required parameter ioName when calling readAnalogOutputEu');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: FloatValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name and engineering units (EU) for all analog output points in the strategy
     */
    public readAnalogOutputs(): Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/analogOutputs';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<FloatVar>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns controller&#39;s type, e.g. \&quot;SNAP-PAC-R1\&quot;; firmware version; both mac addresses; and uptime in seconds
     */
    public readDeviceDetails(): Promise<{ response: http.ClientResponse; body: ControllerResponse; }>
    {
        const localVarPath = this.basePath + '/device';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: ControllerResponse; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the specified digital input point&#39;s state (true &#x3D; on, false &#x3D; off)
     * @param ioName Name of the digital input point to read
     */
    public readDigitalInputState(ioName: string): Promise<{ response: http.ClientResponse; body: DigitalPointStateObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/digitalInputs/{ioName}/state'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is set
        if (!ioName) {
            throw new Error('Missing required parameter ioName when calling readDigitalInputState');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: DigitalPointStateObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name and state (true &#x3D; on, false &#x3D; off) of all digital input points in the strategy. If there is no strategy in the controller, or the strategy includes no digital inputs, the returned array will be empty.
     */
    public readDigitalInputs(): Promise<{ response: http.ClientResponse; body: Array<DigitalPointStateVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/digitalInputs';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<DigitalPointStateVar>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the specified digital output point&#39;s state (true &#x3D; on, false &#x3D; off)
     * @param ioName Name of the digit output point to read
     */
    public readDigitalOutputState(ioName: string): Promise<{ response: http.ClientResponse; body: DigitalPointStateObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/digitalOutputs/{ioName}/state'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is set
        if (!ioName) {
            throw new Error('Missing required parameter ioName when calling readDigitalOutputState');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: DigitalPointStateObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name and state (true &#x3D; on, false &#x3D; off) of all digital output points in the strategy
     */
    public readDigitalOutputs(): Promise<{ response: http.ClientResponse; body: Array<DigitalPointStateVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/digitalOutputs';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<DigitalPointStateVar>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns current value of the specified down timer
     * @param downTimerName Name of the down timer variable to read
     */
    public readDownTimerValue(downTimerName: string): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/downTimers/{downTimerName}/value'
            .replace('{' + 'downTimerName' + '}', String(downTimerName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'downTimerName' is set
        if (!downTimerName) {
            throw new Error('Missing required parameter downTimerName when calling readDownTimerValue');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: FloatValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name and current value of all down timers in the strategy
     */
    public readDownTimerVars(): Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/downTimers';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<FloatVar>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Read table elements
     * @param tableName Name of float table to read; starting index and number of elements may be specified (defaults to all elements)
     * @param startIndex Index of first element to read (default is 0)
     * @param numElements Number of elements to read (default is number of elements in the table minus startIndex)
     */
    public readFloatTable(tableName: string, startIndex?: number, numElements?: number): Promise<{ response: http.ClientResponse; body: Array<number>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/floats/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling readFloatTable');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (numElements !== undefined) {
            queryParameters['numElements'] = numElements;
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<number>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Read specified table element
     * @param tableName Name of float table to read
     * @param index Index of element to read
     */
    public readFloatTableElement(tableName: string, index: number): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/floats/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling readFloatTableElement');
        }

        // verify required parameter 'index' is set
        if (!index) {
            throw new Error('Missing required parameter index when calling readFloatTableElement');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: FloatValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns a list of the name and length of all the float tables in the strategy
     */
    public readFloatTables(): Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/floats';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<TableDef>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns value of the specified float variable
     * @param floatName Name of float variable to read
     */
    public readFloatVar(floatName: string): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/floats/{floatName}'
            .replace('{' + 'floatName' + '}', String(floatName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'floatName' is set
        if (!floatName) {
            throw new Error('Missing required parameter floatName when calling readFloatVar');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: FloatValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name and value of all (single-precision) float variables in the strategy
     */
    public readFloatVars(): Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/floats';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<FloatVar>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Read a range of table elements from the specified integer32 table
     * @param tableName Name of integer32 table to read; starting index and number of elements may be specified (defaults to all elements)
     * @param startIndex Index of first element to read (default is 0)
     * @param numElements Number of elements to read (default is number of elements in the table minus startIndex)
     */
    public readInt32Table(tableName: string, startIndex?: number, numElements?: number): Promise<{ response: http.ClientResponse; body: Array<number>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int32s/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling readInt32Table');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (numElements !== undefined) {
            queryParameters['numElements'] = numElements;
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<number>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Read specified integer32 table element
     * @param tableName Name of the integer32 table to read
     * @param index Index of element to read
     */
    public readInt32TableElement(tableName: string, index: number): Promise<{ response: http.ClientResponse; body: Int32ValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int32s/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling readInt32TableElement');
        }

        // verify required parameter 'index' is set
        if (!index) {
            throw new Error('Missing required parameter index when calling readInt32TableElement');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Int32ValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns a list of the name and length of all the integer32 tables in the strategy
     */
    public readInt32Tables(): Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int32s';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<TableDef>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns value of the specified integer32 variable
     * @param int32Name Name of integer32 variable to read
     */
    public readInt32Var(int32Name: string): Promise<{ response: http.ClientResponse; body: Int32ValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int32s/{int32Name}'
            .replace('{' + 'int32Name' + '}', String(int32Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int32Name' is set
        if (!int32Name) {
            throw new Error('Missing required parameter int32Name when calling readInt32Var');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Int32ValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name and value of all integer32 variables in the strategy
     */
    public readInt32Vars(): Promise<{ response: http.ClientResponse; body: Array<Int32Var>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int32s';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<Int32Var>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Read table elements
     * @param tableName Name of the integer64 table to read; starting index and number of elements may be specified (defaults to all elements)
     * @param startIndex Index of first element to read (default is 0)
     * @param numElements Number of elements to read (default is number of elements in the table minus startIndex)
     */
    public readInt64Table(tableName: string, startIndex?: number, numElements?: number): Promise<{ response: http.ClientResponse; body: Array<number>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling readInt64Table');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (numElements !== undefined) {
            queryParameters['numElements'] = numElements;
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<number>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Read table elements as strings
     * @param tableName Name of the integer64 table to read; starting index and number of elements may be specified (defaults to all elements)
     * @param startIndex Index of first element to read (default is 0)
     * @param numElements Number of elements to read (default is number of elements in the table minus startIndex)
     */
    public readInt64TableAsString(tableName: string, startIndex?: number, numElements?: number): Promise<{ response: http.ClientResponse; body: Array<string>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/_string'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling readInt64TableAsString');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (numElements !== undefined) {
            queryParameters['numElements'] = numElements;
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<string>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Read specified integer64 table element
     * @param tableName Name of integer64 table to read
     * @param index Index of element to read
     */
    public readInt64TableElement(tableName: string, index: number): Promise<{ response: http.ClientResponse; body: Int64ValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling readInt64TableElement');
        }

        // verify required parameter 'index' is set
        if (!index) {
            throw new Error('Missing required parameter index when calling readInt64TableElement');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Int64ValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Read specified integer64 table element as string
     * @param tableName Name of integer64 table to read
     * @param index Index of element to read
     */
    public readInt64TableElementAsString(tableName: string, index: number): Promise<{ response: http.ClientResponse; body: Int64StringValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/{index}/_string'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling readInt64TableElementAsString');
        }

        // verify required parameter 'index' is set
        if (!index) {
            throw new Error('Missing required parameter index when calling readInt64TableElementAsString');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Int64StringValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns a list of the name and length of all the integer64 tables in the strategy
     */
    public readInt64Tables(): Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<TableDef>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns value of the specified integer64 variable
     * @param int64Name Name of integer64 variable to read
     */
    public readInt64Var(int64Name: string): Promise<{ response: http.ClientResponse; body: Int64ValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s/{int64Name}'
            .replace('{' + 'int64Name' + '}', String(int64Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int64Name' is set
        if (!int64Name) {
            throw new Error('Missing required parameter int64Name when calling readInt64Var');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Int64ValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns value of the specified integer64 variable as a string
     * @param int64Name Name of integer64 variable to read
     */
    public readInt64VarAsString(int64Name: string): Promise<{ response: http.ClientResponse; body: Int64StringValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s/{int64Name}/_string'
            .replace('{' + 'int64Name' + '}', String(int64Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int64Name' is set
        if (!int64Name) {
            throw new Error('Missing required parameter int64Name when calling readInt64VarAsString');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Int64StringValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name and value of all integer64 variables in the strategy
     */
    public readInt64Vars(): Promise<{ response: http.ClientResponse; body: Array<Int64Var>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<Int64Var>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name and value as a string of all integer64 variables in the strategy
     */
    public readInt64VarsAsStrings(): Promise<{ response: http.ClientResponse; body: Array<Int64VarAsString>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s/_string';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<Int64VarAsString>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name, date, time, and CRC of the strategy currently in the controller, and the number of charts currently running. Empty strings and a 0 will be returned when there is no strategy.
     */
    public readStrategyDetails(): Promise<{ response: http.ClientResponse; body: StrategyResponse; }>
    {
        const localVarPath = this.basePath + '/device/strategy';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: StrategyResponse; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Read table elements
     * @param tableName Name of string table to read; starting index and number of elements may be specified (defaults to all elements)
     * @param startIndex Index of first element to read (default is 0)
     * @param numElements Number of elements to read (default is number of elements in the table minus startIndex)
     */
    public readStringTable(tableName: string, startIndex?: number, numElements?: number): Promise<{ response: http.ClientResponse; body: Array<string>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/strings/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling readStringTable');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (numElements !== undefined) {
            queryParameters['numElements'] = numElements;
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<string>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Read specified table element
     * @param tableName Name of string table to read
     * @param index Index of element to read
     */
    public readStringTableElement(tableName: string, index: number): Promise<{ response: http.ClientResponse; body: StringValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/strings/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling readStringTableElement');
        }

        // verify required parameter 'index' is set
        if (!index) {
            throw new Error('Missing required parameter index when calling readStringTableElement');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: StringValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns a list of the name and length of all the string tables in the strategy
     */
    public readStringTables(): Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/strings';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<TableDef>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns value of the specified string
     * @param stringName Name of string variable to read
     */
    public readStringVar(stringName: string): Promise<{ response: http.ClientResponse; body: StringValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/strings/{stringName}'
            .replace('{' + 'stringName' + '}', String(stringName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stringName' is set
        if (!stringName) {
            throw new Error('Missing required parameter stringName when calling readStringVar');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: StringValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name and value of all string variables in the strategy
     */
    public readStringVars(): Promise<{ response: http.ClientResponse; body: Array<StringVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/strings';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<StringVar>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns current value of the specified up timer
     * @param upTimerName Name of the up timer variable to read
     */
    public readUpTimerValue(upTimerName: string): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/upTimers/{upTimerName}/value'
            .replace('{' + 'upTimerName' + '}', String(upTimerName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'upTimerName' is set
        if (!upTimerName) {
            throw new Error('Missing required parameter upTimerName when calling readUpTimerValue');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: FloatValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name and current value of all up timers in the strategy
     */
    public readUpTimerVars(): Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/upTimers';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<FloatVar>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Sets the value of the specified analog output point
     * @param ioName Name of the analog output point to write
     * @param body Value to write
     */
    public writeAnalogOutputEu(ioName: string, body: FloatValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/analogOutputs/{ioName}/eu'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is set
        if (!ioName) {
            throw new Error('Missing required parameter ioName when calling writeAnalogOutputEu');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling writeAnalogOutputEu');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Sets the value of the specified digital output point
     * @param ioName Name of the digital output point to write
     * @param body Value to write
     */
    public writeDigitalOutputState(ioName: string, body: DigitalPointStateObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/digitalOutputs/{ioName}/state'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is set
        if (!ioName) {
            throw new Error('Missing required parameter ioName when calling writeDigitalOutputState');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling writeDigitalOutputState');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Write table elements
     * @param tableName Name of float table to write; starting index may be specified
     * @param stringList List of element values to write starting at startIndex
     * @param startIndex Index of first element to write (default is 0)
     */
    public writeFloatTable(tableName: string, stringList: Array<number>, startIndex?: number): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/floats/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling writeFloatTable');
        }

        // verify required parameter 'stringList' is set
        if (!stringList) {
            throw new Error('Missing required parameter stringList when calling writeFloatTable');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: stringList,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Write specified table element
     * @param tableName Name of float table to write
     * @param index Index of element to write
     * @param floatElementObject Element to write starting at index
     */
    public writeFloatTableElement(tableName: string, index: number, floatElementObject: FloatValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/floats/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling writeFloatTableElement');
        }

        // verify required parameter 'index' is set
        if (!index) {
            throw new Error('Missing required parameter index when calling writeFloatTableElement');
        }

        // verify required parameter 'floatElementObject' is set
        if (!floatElementObject) {
            throw new Error('Missing required parameter floatElementObject when calling writeFloatTableElement');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: floatElementObject,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Sets the value of a float variable
     * @param floatName Name of the float variable to write
     * @param body Value to write to the float variable
     */
    public writeFloatVar(floatName: string, body: FloatValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/floats/{floatName}'
            .replace('{' + 'floatName' + '}', String(floatName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'floatName' is set
        if (!floatName) {
            throw new Error('Missing required parameter floatName when calling writeFloatVar');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling writeFloatVar');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Write a range of table elements
     * @param tableName Name of integer32 table to write; starting index may be specified
     * @param stringList List of element values to write starting at startIndex; if the list of elements is too long to fit in the specified table, extra elements will be ignored
     * @param startIndex Index of first element to write (default is 0)
     */
    public writeInt32Table(tableName: string, stringList: Array<number>, startIndex?: number): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int32s/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling writeInt32Table');
        }

        // verify required parameter 'stringList' is set
        if (!stringList) {
            throw new Error('Missing required parameter stringList when calling writeInt32Table');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: stringList,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Write specified integer32 table element
     * @param tableName Name of the integer32 table to write
     * @param index Index of element to write
     * @param int32ElementObject Element to write at index specified
     */
    public writeInt32TableElement(tableName: string, index: number, int32ElementObject: Int32ValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int32s/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling writeInt32TableElement');
        }

        // verify required parameter 'index' is set
        if (!index) {
            throw new Error('Missing required parameter index when calling writeInt32TableElement');
        }

        // verify required parameter 'int32ElementObject' is set
        if (!int32ElementObject) {
            throw new Error('Missing required parameter int32ElementObject when calling writeInt32TableElement');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: int32ElementObject,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Sets the value of an integer32 variable
     * @param int32Name Name of integer32 variable to write
     * @param body Value to write to the integer32 variable
     */
    public writeInt32Var(int32Name: string, body: Int32ValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int32s/{int32Name}'
            .replace('{' + 'int32Name' + '}', String(int32Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int32Name' is set
        if (!int32Name) {
            throw new Error('Missing required parameter int32Name when calling writeInt32Var');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling writeInt32Var');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Write table elements
     * @param tableName Name of integer64 table to write; starting index may be specified
     * @param stringList List of element values to write starting at startIndex; if the list of elements is too long to fit in the specified table, extra elements will be ignored
     * @param startIndex Index of first element to write; default is 0
     */
    public writeInt64Table(tableName: string, stringList: Array<number>, startIndex?: number): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling writeInt64Table');
        }

        // verify required parameter 'stringList' is set
        if (!stringList) {
            throw new Error('Missing required parameter stringList when calling writeInt64Table');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: stringList,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Write table elements as strings
     * @param tableName Name of integer64 table to write; starting index may be specified
     * @param stringList List of element values to write starting at startIndex; if the list of elements is too long to fit in the specified table, extra elements will be ignored
     * @param startIndex Index of first element to write; default is 0.
     */
    public writeInt64TableAsString(tableName: string, stringList: Array<string>, startIndex?: number): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/_string'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling writeInt64TableAsString');
        }

        // verify required parameter 'stringList' is set
        if (!stringList) {
            throw new Error('Missing required parameter stringList when calling writeInt64TableAsString');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: stringList,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Write specified integer64 table element
     * @param tableName Name of the integer64 table to write
     * @param index Index of element to write
     * @param int64ElementObject Element to write starting at index specified
     */
    public writeInt64TableElement(tableName: string, index: number, int64ElementObject: Int64ValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling writeInt64TableElement');
        }

        // verify required parameter 'index' is set
        if (!index) {
            throw new Error('Missing required parameter index when calling writeInt64TableElement');
        }

        // verify required parameter 'int64ElementObject' is set
        if (!int64ElementObject) {
            throw new Error('Missing required parameter int64ElementObject when calling writeInt64TableElement');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: int64ElementObject,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Write specified integer64 table element as string
     * @param tableName Name of the integer64 table to write
     * @param index Index of element to write
     * @param int64ElementObject Element to write starting at index specified
     */
    public writeInt64TableElementAsString(tableName: string, index: number, int64ElementObject: Int64StringValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/{index}/_string'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling writeInt64TableElementAsString');
        }

        // verify required parameter 'index' is set
        if (!index) {
            throw new Error('Missing required parameter index when calling writeInt64TableElementAsString');
        }

        // verify required parameter 'int64ElementObject' is set
        if (!int64ElementObject) {
            throw new Error('Missing required parameter int64ElementObject when calling writeInt64TableElementAsString');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: int64ElementObject,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Sets the value of an integer64 variable
     * @param int64Name Name of integer64 variable to write
     * @param body Value to write to the integer64 variable
     */
    public writeInt64Var(int64Name: string, body: Int64ValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s/{int64Name}'
            .replace('{' + 'int64Name' + '}', String(int64Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int64Name' is set
        if (!int64Name) {
            throw new Error('Missing required parameter int64Name when calling writeInt64Var');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling writeInt64Var');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Sets the value of an integer64 variable as a string
     * @param int64Name Name of integer64 variable to write
     * @param body Value to write to the integer64 variable
     */
    public writeInt64VarAsString(int64Name: string, body: Int64StringValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s/{int64Name}/_string'
            .replace('{' + 'int64Name' + '}', String(int64Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int64Name' is set
        if (!int64Name) {
            throw new Error('Missing required parameter int64Name when calling writeInt64VarAsString');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling writeInt64VarAsString');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Write table elements
     * @param tableName Name of string table to write; starting index may be specified
     * @param stringList List of element values to write starting at startIndex; if an element value is longer than the string width, the string will be truncated to fit
     * @param startIndex Index of first element to write (default is 0)
     */
    public writeStringTable(tableName: string, stringList: Array<string>, startIndex?: number): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/strings/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling writeStringTable');
        }

        // verify required parameter 'stringList' is set
        if (!stringList) {
            throw new Error('Missing required parameter stringList when calling writeStringTable');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: stringList,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Write specified table element
     * @param tableName Name of string table to write
     * @param index Index of element to write
     * @param stringElementObject Element to write starting at index
     */
    public writeStringTableElement(tableName: string, index: number, stringElementObject: StringValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/strings/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling writeStringTableElement');
        }

        // verify required parameter 'index' is set
        if (!index) {
            throw new Error('Missing required parameter index when calling writeStringTableElement');
        }

        // verify required parameter 'stringElementObject' is set
        if (!stringElementObject) {
            throw new Error('Missing required parameter stringElementObject when calling writeStringTableElement');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: stringElementObject,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Sets the value of a string variable
     * @param stringName Name of string variable to write
     * @param body String to write
     */
    public writeStringVar(stringName: string, body: StringValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/strings/{stringName}'
            .replace('{' + 'stringName' + '}', String(stringName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stringName' is set
        if (!stringName) {
            throw new Error('Missing required parameter stringName when calling writeStringVar');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling writeStringVar');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
export enum DeviceApiApiKeys
{
}

export class DeviceApi
{
    protected basePath = 'http://restpac.groov.com/api/v1';
    protected defaultHeaders: any = {};

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string)
    {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    public setApiKey(key: DeviceApiApiKeys, value: string)
    {
        this.authentications[DeviceApiApiKeys[key]].apiKey = value;
    }

    set username(username: string)
    {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string)
    {
        this.authentications.basicAuth.password = password;
    }
    private extendObj<T1, T2>(objA: T1, objB: T2)
    {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return <T1 & T2>objA;
    }
    /**
     * 
     * Returns controller&#39;s type, e.g. \&quot;SNAP-PAC-R1\&quot;; firmware version; both mac addresses; and uptime in seconds
     */
    public readDeviceDetails(): Promise<{ response: http.ClientResponse; body: ControllerResponse; }>
    {
        const localVarPath = this.basePath + '/device';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: ControllerResponse; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
export enum IosApiApiKeys
{
}

export class IosApi
{
    protected basePath = 'http://restpac.groov.com/api/v1';
    protected defaultHeaders: any = {};

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string)
    {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    public setApiKey(key: IosApiApiKeys, value: string)
    {
        this.authentications[IosApiApiKeys[key]].apiKey = value;
    }

    set username(username: string)
    {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string)
    {
        this.authentications.basicAuth.password = password;
    }
    private extendObj<T1, T2>(objA: T1, objB: T2)
    {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return <T1 & T2>objA;
    }
    /**
     * 
     * Reads the value in engineering units (EU) of the specified analog input
     * @param ioName Name of the analog input point to read
     */
    public readAnalogInputEu(ioName: string): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/analogInputs/{ioName}/eu'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is set
        if (!ioName) {
            throw new Error('Missing required parameter ioName when calling readAnalogInputEu');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: FloatValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name and engineering units (EU) for all analog input points in the strategy
     */
    public readAnalogInputs(): Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/analogInputs';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<FloatVar>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Reads the value in engineering units (EU) of the specified analog output
     * @param ioName Name of analog output point to read
     */
    public readAnalogOutputEu(ioName: string): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/analogOutputs/{ioName}/eu'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is set
        if (!ioName) {
            throw new Error('Missing required parameter ioName when calling readAnalogOutputEu');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: FloatValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name and engineering units (EU) for all analog output points in the strategy
     */
    public readAnalogOutputs(): Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/analogOutputs';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<FloatVar>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the specified digital input point&#39;s state (true &#x3D; on, false &#x3D; off)
     * @param ioName Name of the digital input point to read
     */
    public readDigitalInputState(ioName: string): Promise<{ response: http.ClientResponse; body: DigitalPointStateObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/digitalInputs/{ioName}/state'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is set
        if (!ioName) {
            throw new Error('Missing required parameter ioName when calling readDigitalInputState');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: DigitalPointStateObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name and state (true &#x3D; on, false &#x3D; off) of all digital input points in the strategy. If there is no strategy in the controller, or the strategy includes no digital inputs, the returned array will be empty.
     */
    public readDigitalInputs(): Promise<{ response: http.ClientResponse; body: Array<DigitalPointStateVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/digitalInputs';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<DigitalPointStateVar>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the specified digital output point&#39;s state (true &#x3D; on, false &#x3D; off)
     * @param ioName Name of the digit output point to read
     */
    public readDigitalOutputState(ioName: string): Promise<{ response: http.ClientResponse; body: DigitalPointStateObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/digitalOutputs/{ioName}/state'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is set
        if (!ioName) {
            throw new Error('Missing required parameter ioName when calling readDigitalOutputState');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: DigitalPointStateObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name and state (true &#x3D; on, false &#x3D; off) of all digital output points in the strategy
     */
    public readDigitalOutputs(): Promise<{ response: http.ClientResponse; body: Array<DigitalPointStateVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/digitalOutputs';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<DigitalPointStateVar>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Sets the value of the specified analog output point
     * @param ioName Name of the analog output point to write
     * @param body Value to write
     */
    public writeAnalogOutputEu(ioName: string, body: FloatValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/analogOutputs/{ioName}/eu'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is set
        if (!ioName) {
            throw new Error('Missing required parameter ioName when calling writeAnalogOutputEu');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling writeAnalogOutputEu');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Sets the value of the specified digital output point
     * @param ioName Name of the digital output point to write
     * @param body Value to write
     */
    public writeDigitalOutputState(ioName: string, body: DigitalPointStateObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/digitalOutputs/{ioName}/state'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is set
        if (!ioName) {
            throw new Error('Missing required parameter ioName when calling writeDigitalOutputState');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling writeDigitalOutputState');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
export enum StrategyApiApiKeys
{
}

export class StrategyApi
{
    protected basePath = 'http://restpac.groov.com/api/v1';
    protected defaultHeaders: any = {};

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string)
    {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    public setApiKey(key: StrategyApiApiKeys, value: string)
    {
        this.authentications[StrategyApiApiKeys[key]].apiKey = value;
    }

    set username(username: string)
    {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string)
    {
        this.authentications.basicAuth.password = password;
    }
    private extendObj<T1, T2>(objA: T1, objB: T2)
    {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return <T1 & T2>objA;
    }
    /**
     * 
     * Returns the name, date, time, and CRC of the strategy currently in the controller, and the number of charts currently running. Empty strings and a 0 will be returned when there is no strategy.
     */
    public readStrategyDetails(): Promise<{ response: http.ClientResponse; body: StrategyResponse; }>
    {
        const localVarPath = this.basePath + '/device/strategy';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: StrategyResponse; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
export enum TablesApiApiKeys
{
}

export class TablesApi
{
    protected basePath = 'http://restpac.groov.com/api/v1';
    protected defaultHeaders: any = {};

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string)
    {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    public setApiKey(key: TablesApiApiKeys, value: string)
    {
        this.authentications[TablesApiApiKeys[key]].apiKey = value;
    }

    set username(username: string)
    {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string)
    {
        this.authentications.basicAuth.password = password;
    }
    private extendObj<T1, T2>(objA: T1, objB: T2)
    {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return <T1 & T2>objA;
    }
    /**
     * 
     * Read table elements
     * @param tableName Name of float table to read; starting index and number of elements may be specified (defaults to all elements)
     * @param startIndex Index of first element to read (default is 0)
     * @param numElements Number of elements to read (default is number of elements in the table minus startIndex)
     */
    public readFloatTable(tableName: string, startIndex?: number, numElements?: number): Promise<{ response: http.ClientResponse; body: Array<number>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/floats/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling readFloatTable');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (numElements !== undefined) {
            queryParameters['numElements'] = numElements;
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<number>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Read specified table element
     * @param tableName Name of float table to read
     * @param index Index of element to read
     */
    public readFloatTableElement(tableName: string, index: number): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/floats/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling readFloatTableElement');
        }

        // verify required parameter 'index' is set
        if (!index) {
            throw new Error('Missing required parameter index when calling readFloatTableElement');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: FloatValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns a list of the name and length of all the float tables in the strategy
     */
    public readFloatTables(): Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/floats';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<TableDef>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Read a range of table elements from the specified integer32 table
     * @param tableName Name of integer32 table to read; starting index and number of elements may be specified (defaults to all elements)
     * @param startIndex Index of first element to read (default is 0)
     * @param numElements Number of elements to read (default is number of elements in the table minus startIndex)
     */
    public readInt32Table(tableName: string, startIndex?: number, numElements?: number): Promise<{ response: http.ClientResponse; body: Array<number>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int32s/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling readInt32Table');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (numElements !== undefined) {
            queryParameters['numElements'] = numElements;
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<number>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Read specified integer32 table element
     * @param tableName Name of the integer32 table to read
     * @param index Index of element to read
     */
    public readInt32TableElement(tableName: string, index: number): Promise<{ response: http.ClientResponse; body: Int32ValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int32s/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling readInt32TableElement');
        }

        // verify required parameter 'index' is set
        if (!index) {
            throw new Error('Missing required parameter index when calling readInt32TableElement');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Int32ValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns a list of the name and length of all the integer32 tables in the strategy
     */
    public readInt32Tables(): Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int32s';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<TableDef>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Read table elements
     * @param tableName Name of the integer64 table to read; starting index and number of elements may be specified (defaults to all elements)
     * @param startIndex Index of first element to read (default is 0)
     * @param numElements Number of elements to read (default is number of elements in the table minus startIndex)
     */
    public readInt64Table(tableName: string, startIndex?: number, numElements?: number): Promise<{ response: http.ClientResponse; body: Array<number>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling readInt64Table');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (numElements !== undefined) {
            queryParameters['numElements'] = numElements;
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<number>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Read table elements as strings
     * @param tableName Name of the integer64 table to read; starting index and number of elements may be specified (defaults to all elements)
     * @param startIndex Index of first element to read (default is 0)
     * @param numElements Number of elements to read (default is number of elements in the table minus startIndex)
     */
    public readInt64TableAsString(tableName: string, startIndex?: number, numElements?: number): Promise<{ response: http.ClientResponse; body: Array<string>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/_string'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling readInt64TableAsString');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (numElements !== undefined) {
            queryParameters['numElements'] = numElements;
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<string>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Read specified integer64 table element
     * @param tableName Name of integer64 table to read
     * @param index Index of element to read
     */
    public readInt64TableElement(tableName: string, index: number): Promise<{ response: http.ClientResponse; body: Int64ValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling readInt64TableElement');
        }

        // verify required parameter 'index' is set
        if (!index) {
            throw new Error('Missing required parameter index when calling readInt64TableElement');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Int64ValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Read specified integer64 table element as string
     * @param tableName Name of integer64 table to read
     * @param index Index of element to read
     */
    public readInt64TableElementAsString(tableName: string, index: number): Promise<{ response: http.ClientResponse; body: Int64StringValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/{index}/_string'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling readInt64TableElementAsString');
        }

        // verify required parameter 'index' is set
        if (!index) {
            throw new Error('Missing required parameter index when calling readInt64TableElementAsString');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Int64StringValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns a list of the name and length of all the integer64 tables in the strategy
     */
    public readInt64Tables(): Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<TableDef>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Read table elements
     * @param tableName Name of string table to read; starting index and number of elements may be specified (defaults to all elements)
     * @param startIndex Index of first element to read (default is 0)
     * @param numElements Number of elements to read (default is number of elements in the table minus startIndex)
     */
    public readStringTable(tableName: string, startIndex?: number, numElements?: number): Promise<{ response: http.ClientResponse; body: Array<string>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/strings/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling readStringTable');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (numElements !== undefined) {
            queryParameters['numElements'] = numElements;
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<string>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Read specified table element
     * @param tableName Name of string table to read
     * @param index Index of element to read
     */
    public readStringTableElement(tableName: string, index: number): Promise<{ response: http.ClientResponse; body: StringValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/strings/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling readStringTableElement');
        }

        // verify required parameter 'index' is set
        if (!index) {
            throw new Error('Missing required parameter index when calling readStringTableElement');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: StringValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns a list of the name and length of all the string tables in the strategy
     */
    public readStringTables(): Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/strings';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<TableDef>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Write table elements
     * @param tableName Name of float table to write; starting index may be specified
     * @param stringList List of element values to write starting at startIndex
     * @param startIndex Index of first element to write (default is 0)
     */
    public writeFloatTable(tableName: string, stringList: Array<number>, startIndex?: number): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/floats/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling writeFloatTable');
        }

        // verify required parameter 'stringList' is set
        if (!stringList) {
            throw new Error('Missing required parameter stringList when calling writeFloatTable');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: stringList,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Write specified table element
     * @param tableName Name of float table to write
     * @param index Index of element to write
     * @param floatElementObject Element to write starting at index
     */
    public writeFloatTableElement(tableName: string, index: number, floatElementObject: FloatValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/floats/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling writeFloatTableElement');
        }

        // verify required parameter 'index' is set
        if (!index) {
            throw new Error('Missing required parameter index when calling writeFloatTableElement');
        }

        // verify required parameter 'floatElementObject' is set
        if (!floatElementObject) {
            throw new Error('Missing required parameter floatElementObject when calling writeFloatTableElement');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: floatElementObject,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Write a range of table elements
     * @param tableName Name of integer32 table to write; starting index may be specified
     * @param stringList List of element values to write starting at startIndex; if the list of elements is too long to fit in the specified table, extra elements will be ignored
     * @param startIndex Index of first element to write (default is 0)
     */
    public writeInt32Table(tableName: string, stringList: Array<number>, startIndex?: number): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int32s/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling writeInt32Table');
        }

        // verify required parameter 'stringList' is set
        if (!stringList) {
            throw new Error('Missing required parameter stringList when calling writeInt32Table');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: stringList,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Write specified integer32 table element
     * @param tableName Name of the integer32 table to write
     * @param index Index of element to write
     * @param int32ElementObject Element to write at index specified
     */
    public writeInt32TableElement(tableName: string, index: number, int32ElementObject: Int32ValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int32s/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling writeInt32TableElement');
        }

        // verify required parameter 'index' is set
        if (!index) {
            throw new Error('Missing required parameter index when calling writeInt32TableElement');
        }

        // verify required parameter 'int32ElementObject' is set
        if (!int32ElementObject) {
            throw new Error('Missing required parameter int32ElementObject when calling writeInt32TableElement');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: int32ElementObject,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Write table elements
     * @param tableName Name of integer64 table to write; starting index may be specified
     * @param stringList List of element values to write starting at startIndex; if the list of elements is too long to fit in the specified table, extra elements will be ignored
     * @param startIndex Index of first element to write; default is 0
     */
    public writeInt64Table(tableName: string, stringList: Array<number>, startIndex?: number): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling writeInt64Table');
        }

        // verify required parameter 'stringList' is set
        if (!stringList) {
            throw new Error('Missing required parameter stringList when calling writeInt64Table');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: stringList,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Write table elements as strings
     * @param tableName Name of integer64 table to write; starting index may be specified
     * @param stringList List of element values to write starting at startIndex; if the list of elements is too long to fit in the specified table, extra elements will be ignored
     * @param startIndex Index of first element to write; default is 0.
     */
    public writeInt64TableAsString(tableName: string, stringList: Array<string>, startIndex?: number): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/_string'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling writeInt64TableAsString');
        }

        // verify required parameter 'stringList' is set
        if (!stringList) {
            throw new Error('Missing required parameter stringList when calling writeInt64TableAsString');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: stringList,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Write specified integer64 table element
     * @param tableName Name of the integer64 table to write
     * @param index Index of element to write
     * @param int64ElementObject Element to write starting at index specified
     */
    public writeInt64TableElement(tableName: string, index: number, int64ElementObject: Int64ValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling writeInt64TableElement');
        }

        // verify required parameter 'index' is set
        if (!index) {
            throw new Error('Missing required parameter index when calling writeInt64TableElement');
        }

        // verify required parameter 'int64ElementObject' is set
        if (!int64ElementObject) {
            throw new Error('Missing required parameter int64ElementObject when calling writeInt64TableElement');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: int64ElementObject,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Write specified integer64 table element as string
     * @param tableName Name of the integer64 table to write
     * @param index Index of element to write
     * @param int64ElementObject Element to write starting at index specified
     */
    public writeInt64TableElementAsString(tableName: string, index: number, int64ElementObject: Int64StringValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/{index}/_string'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling writeInt64TableElementAsString');
        }

        // verify required parameter 'index' is set
        if (!index) {
            throw new Error('Missing required parameter index when calling writeInt64TableElementAsString');
        }

        // verify required parameter 'int64ElementObject' is set
        if (!int64ElementObject) {
            throw new Error('Missing required parameter int64ElementObject when calling writeInt64TableElementAsString');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: int64ElementObject,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Write table elements
     * @param tableName Name of string table to write; starting index may be specified
     * @param stringList List of element values to write starting at startIndex; if an element value is longer than the string width, the string will be truncated to fit
     * @param startIndex Index of first element to write (default is 0)
     */
    public writeStringTable(tableName: string, stringList: Array<string>, startIndex?: number): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/strings/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling writeStringTable');
        }

        // verify required parameter 'stringList' is set
        if (!stringList) {
            throw new Error('Missing required parameter stringList when calling writeStringTable');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: stringList,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Write specified table element
     * @param tableName Name of string table to write
     * @param index Index of element to write
     * @param stringElementObject Element to write starting at index
     */
    public writeStringTableElement(tableName: string, index: number, stringElementObject: StringValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/strings/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is set
        if (!tableName) {
            throw new Error('Missing required parameter tableName when calling writeStringTableElement');
        }

        // verify required parameter 'index' is set
        if (!index) {
            throw new Error('Missing required parameter index when calling writeStringTableElement');
        }

        // verify required parameter 'stringElementObject' is set
        if (!stringElementObject) {
            throw new Error('Missing required parameter stringElementObject when calling writeStringTableElement');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: stringElementObject,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
export enum VarsApiApiKeys
{
}

export class VarsApi
{
    protected basePath = 'http://restpac.groov.com/api/v1';
    protected defaultHeaders: any = {};

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string)
    {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    public setApiKey(key: VarsApiApiKeys, value: string)
    {
        this.authentications[VarsApiApiKeys[key]].apiKey = value;
    }

    set username(username: string)
    {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string)
    {
        this.authentications.basicAuth.password = password;
    }
    private extendObj<T1, T2>(objA: T1, objB: T2)
    {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return <T1 & T2>objA;
    }
    /**
     * 
     * Returns current value of the specified down timer
     * @param downTimerName Name of the down timer variable to read
     */
    public readDownTimerValue(downTimerName: string): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/downTimers/{downTimerName}/value'
            .replace('{' + 'downTimerName' + '}', String(downTimerName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'downTimerName' is set
        if (!downTimerName) {
            throw new Error('Missing required parameter downTimerName when calling readDownTimerValue');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: FloatValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name and current value of all down timers in the strategy
     */
    public readDownTimerVars(): Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/downTimers';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<FloatVar>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns value of the specified float variable
     * @param floatName Name of float variable to read
     */
    public readFloatVar(floatName: string): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/floats/{floatName}'
            .replace('{' + 'floatName' + '}', String(floatName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'floatName' is set
        if (!floatName) {
            throw new Error('Missing required parameter floatName when calling readFloatVar');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: FloatValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name and value of all (single-precision) float variables in the strategy
     */
    public readFloatVars(): Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/floats';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<FloatVar>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns value of the specified integer32 variable
     * @param int32Name Name of integer32 variable to read
     */
    public readInt32Var(int32Name: string): Promise<{ response: http.ClientResponse; body: Int32ValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int32s/{int32Name}'
            .replace('{' + 'int32Name' + '}', String(int32Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int32Name' is set
        if (!int32Name) {
            throw new Error('Missing required parameter int32Name when calling readInt32Var');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Int32ValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name and value of all integer32 variables in the strategy
     */
    public readInt32Vars(): Promise<{ response: http.ClientResponse; body: Array<Int32Var>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int32s';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<Int32Var>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns value of the specified integer64 variable
     * @param int64Name Name of integer64 variable to read
     */
    public readInt64Var(int64Name: string): Promise<{ response: http.ClientResponse; body: Int64ValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s/{int64Name}'
            .replace('{' + 'int64Name' + '}', String(int64Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int64Name' is set
        if (!int64Name) {
            throw new Error('Missing required parameter int64Name when calling readInt64Var');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Int64ValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns value of the specified integer64 variable as a string
     * @param int64Name Name of integer64 variable to read
     */
    public readInt64VarAsString(int64Name: string): Promise<{ response: http.ClientResponse; body: Int64StringValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s/{int64Name}/_string'
            .replace('{' + 'int64Name' + '}', String(int64Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int64Name' is set
        if (!int64Name) {
            throw new Error('Missing required parameter int64Name when calling readInt64VarAsString');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Int64StringValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name and value of all integer64 variables in the strategy
     */
    public readInt64Vars(): Promise<{ response: http.ClientResponse; body: Array<Int64Var>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<Int64Var>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name and value as a string of all integer64 variables in the strategy
     */
    public readInt64VarsAsStrings(): Promise<{ response: http.ClientResponse; body: Array<Int64VarAsString>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s/_string';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<Int64VarAsString>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns value of the specified string
     * @param stringName Name of string variable to read
     */
    public readStringVar(stringName: string): Promise<{ response: http.ClientResponse; body: StringValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/strings/{stringName}'
            .replace('{' + 'stringName' + '}', String(stringName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stringName' is set
        if (!stringName) {
            throw new Error('Missing required parameter stringName when calling readStringVar');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: StringValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name and value of all string variables in the strategy
     */
    public readStringVars(): Promise<{ response: http.ClientResponse; body: Array<StringVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/strings';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<StringVar>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns current value of the specified up timer
     * @param upTimerName Name of the up timer variable to read
     */
    public readUpTimerValue(upTimerName: string): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/upTimers/{upTimerName}/value'
            .replace('{' + 'upTimerName' + '}', String(upTimerName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'upTimerName' is set
        if (!upTimerName) {
            throw new Error('Missing required parameter upTimerName when calling readUpTimerValue');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: FloatValueObject; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Returns the name and current value of all up timers in the strategy
     */
    public readUpTimerVars(): Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/upTimers';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body: Array<FloatVar>; }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Sets the value of a float variable
     * @param floatName Name of the float variable to write
     * @param body Value to write to the float variable
     */
    public writeFloatVar(floatName: string, body: FloatValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/floats/{floatName}'
            .replace('{' + 'floatName' + '}', String(floatName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'floatName' is set
        if (!floatName) {
            throw new Error('Missing required parameter floatName when calling writeFloatVar');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling writeFloatVar');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Sets the value of an integer32 variable
     * @param int32Name Name of integer32 variable to write
     * @param body Value to write to the integer32 variable
     */
    public writeInt32Var(int32Name: string, body: Int32ValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int32s/{int32Name}'
            .replace('{' + 'int32Name' + '}', String(int32Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int32Name' is set
        if (!int32Name) {
            throw new Error('Missing required parameter int32Name when calling writeInt32Var');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling writeInt32Var');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Sets the value of an integer64 variable
     * @param int64Name Name of integer64 variable to write
     * @param body Value to write to the integer64 variable
     */
    public writeInt64Var(int64Name: string, body: Int64ValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s/{int64Name}'
            .replace('{' + 'int64Name' + '}', String(int64Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int64Name' is set
        if (!int64Name) {
            throw new Error('Missing required parameter int64Name when calling writeInt64Var');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling writeInt64Var');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Sets the value of an integer64 variable as a string
     * @param int64Name Name of integer64 variable to write
     * @param body Value to write to the integer64 variable
     */
    public writeInt64VarAsString(int64Name: string, body: Int64StringValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s/{int64Name}/_string'
            .replace('{' + 'int64Name' + '}', String(int64Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int64Name' is set
        if (!int64Name) {
            throw new Error('Missing required parameter int64Name when calling writeInt64VarAsString');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling writeInt64VarAsString');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
    /**
     * 
     * Sets the value of a string variable
     * @param stringName Name of string variable to write
     * @param body String to write
     */
    public writeStringVar(stringName: string, body: StringValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/strings/{stringName}'
            .replace('{' + 'stringName' + '}', String(stringName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stringName' is set
        if (!stringName) {
            throw new Error('Missing required parameter stringName when calling writeStringVar');
        }

        // verify required parameter 'body' is set
        if (!body) {
            throw new Error('Missing required parameter body when calling writeStringVar');
        }

        let useFormData = false;

        let localVarDeferred = promise.defer<{ response: http.ClientResponse; body?: any; }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            json: true,
            body: body,
        }

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) =>
        {
            if (error) {
                localVarDeferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    localVarDeferred.resolve({ response: response, body: body });
                } else {
                    localVarDeferred.reject({ response: response, body: body });
                }
            }
        });

        return localVarDeferred.promise;
    }
}
