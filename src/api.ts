/**
 * SNAP PAC REST API
 *
 * OpenAPI spec version: R1.0a
 * Contact: developer@opto22.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'http://restpac.groov.com/api/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class ControllerResponse
{
    'controllerType': string;
    'firmwareVersion': string;
    'firmwareDate': string;
    'firmwareTime': string;
    'mac1': string;
    'mac2': string;
    'upTimeSeconds': number;
}

export class DigitalPointStateObject
{
    /**
    * State of a digital point (true = on, false = off)
    */
    'value': boolean;
}

export class DigitalPointStateVar
{
    /**
    * Name of the tag (strategy variable, i/o point, etc.)
    */
    'name': string;
    /**
    * State of a digital point (true = on, false = off)
    */
    'value': boolean;
}

export class ErrorResponse200OKish
{
    /**
    * Details: ** -23 ** The string you passed is longer than the width of PAC Control string variable or table element you are writing to.
    */
    'errorCode': number;
    'message': string;
}

export class ErrorResponse400BadAdminOrValue
{
    /**
    * Details: ** -1 ** Invalid or no strategy. Use PAC Control to download strategy logic. ** -3 ** Buffer overrun or invalid length. The number or range of table indicies you specified exceeds elements in the PAC Control table. ** -8 ** Invalid data. Check format of data written. Compare to what's read for the same endpoint. ** -12 ** You've passed a table index that is less than zero or greater than the length of the table minus 1. ** -13 ** The value you passed to write is outside of the valid range for the PAC Control data type you're writing to. For example, if you specified the value 999999999999999 for an integer32 (since integer32 data types must be in the range: -2147483648 to 2147483647). ** -17 or -20 ** The controller is busy with another task, for example, downloading a new strategy. Try again later. ** -36 ** Endpoint is not defined. ** -109 ** Attempting to write without write permissions. Check /admin/keys settings. ** -13019 ** Invalid endpoint. Check syntax of the URL (e.g. did you use 'ev' instead of 'eu'). ** 400 ** Before using the API on this device, you must first change the default user name and password via the URL /admin/keys. Use the default User Name: 'admin' and Password: 'password' to log ininitially.
    */
    'errorCode': number;
    'message': string;
}

export class ErrorResponse401BadKeyForBasicAuth
{
    /**
    * Details: ** -104 ** Invalid key ID/value in HTTP header. Before using the API on this device, you must create at least one key ID/value via the URL /admin/keys. Then use one of those in your HTTP header for Basic Authentication.
    */
    'errorCode': number;
    'message': string;
}

export class ErrorResponse404NotFound
{
    /**
    * Details: ** -29 ** The tag (variable, table, timer, I/O point, etc.) you requested exists on the controller but does not match the data type for this endpoint. ** -28 ** The tag (variable, table, timer, I/O point, etc.) does not currently exist on the controller. Check the tag name and the controller's status. ** 404 ** Endpoint does not exist. Check URL.
    */
    'errorCode': number;
    'message': string;
}

export class FloatValueObject
{
    /**
    * Value of the float variable
    */
    'value': number;
}

export class FloatVar
{
    /**
    * Name of the tag (strategy variable, i/o point, etc.)
    */
    'name': string;
    /**
    * Value of the float variable
    */
    'value': number;
}

export class Int32ValueObject
{
    /**
    * Value of the integer32 variable
    */
    'value': number;
}

export class Int32Var
{
    /**
    * Name of the tag (strategy variable, i/o point, etc.)
    */
    'name': string;
    /**
    * Value of the integer32 variable
    */
    'value': number;
}

export class Int64StringValueObject
{
    /**
    * Value of the integer64 variable expressed as decimal string, e.g. \"34359738367\"
    */
    'value': string;
}

export class Int64ValueObject
{
    /**
    * Value of the integer64 variable
    */
    'value': number;
}

export class Int64Var
{
    /**
    * Name of the tag (strategy variable, i/o point, etc.)
    */
    'name': string;
    /**
    * Value of the integer64 variable
    */
    'value': number;
}

export class Int64VarAsString
{
    /**
    * Name of the tag (strategy variable, i/o point, etc.)
    */
    'name': string;
    /**
    * Value of the integer64 variable expressed as a decimal string, E.g. \"34359738367\"
    */
    'value': string;
}

export class StrategyResponse
{
    'strategyName': string;
    'date': string;
    'time': string;
    'crc': string;
    'runningCharts': number;
}

export class StringValueObject
{
    /**
    * The value of a string; string width (max length) for each string variable is defined in the strategy
    */
    'value': string;
}

export class StringVar
{
    /**
    * Name of the tag (strategy variable, i/o point, etc.)
    */
    'name': string;
    /**
    * The value of a string; string width (max length) for each string variable is defined in the strategy
    */
    'value': string;
}

export class TableDef
{
    /**
    * Name of the tag (strategy variable, i/o point, etc.)
    */
    'name': string;
    /**
    * Number of elements contained in this table
    */
    'length': number;
}


export interface Authentication
{
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication
{
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void
    {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication
{
    public apiKey: string;

    constructor(private location: string, private paramName: string)
    {
    }

    applyToRequest(requestOptions: request.Options): void
    {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication
{
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void
    {
        requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
}

export class VoidAuth implements Authentication
{
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void
    {
        // Do nothing
    }
}

export enum AllApiApiKeys
{
}

export class AllApi
{
    protected basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string)
    {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean)
    {
        this._useQuerystring = value;
    }

    public setApiKey(key: AllApiApiKeys, value: string)
    {
        this.authentications[AllApiApiKeys[key]].apiKey = value;
    }
    set username(username: string)
    {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string)
    {
        this.authentications.basicAuth.password = password;
    }
    private extendObj<T1, T2>(objA: T1, objB: T2)
    {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return <T1 & T2>objA;
    }
    /**
     * 
     * Reads the value in engineering units (EU) of the specified analog input
     * @param ioName Name of the analog input point to read
     */
    public readAnalogInputEu(ioName: string): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/analogInputs/{ioName}/eu'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is not null or undefined
        if (ioName === null || ioName === undefined) {
            throw new Error('Required parameter ioName was null or undefined when calling readAnalogInputEu.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FloatValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name and engineering units (EU) for all analog input points in the strategy
     */
    public readAnalogInputs(): Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/analogInputs';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Reads the value in engineering units (EU) of the specified analog output
     * @param ioName Name of analog output point to read
     */
    public readAnalogOutputEu(ioName: string): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/analogOutputs/{ioName}/eu'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is not null or undefined
        if (ioName === null || ioName === undefined) {
            throw new Error('Required parameter ioName was null or undefined when calling readAnalogOutputEu.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FloatValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name and engineering units (EU) for all analog output points in the strategy
     */
    public readAnalogOutputs(): Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/analogOutputs';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns controller&#39;s type, e.g. \&quot;SNAP-PAC-R1\&quot;; firmware version; both mac addresses; and uptime in seconds
     */
    public readDeviceDetails(): Promise<{ response: http.ClientResponse; body: ControllerResponse; }>
    {
        const localVarPath = this.basePath + '/device';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ControllerResponse; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the specified digital input point&#39;s state (true &#x3D; on, false &#x3D; off)
     * @param ioName Name of the digital input point to read
     */
    public readDigitalInputState(ioName: string): Promise<{ response: http.ClientResponse; body: DigitalPointStateObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/digitalInputs/{ioName}/state'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is not null or undefined
        if (ioName === null || ioName === undefined) {
            throw new Error('Required parameter ioName was null or undefined when calling readDigitalInputState.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DigitalPointStateObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name and state (true &#x3D; on, false &#x3D; off) of all digital input points in the strategy. If there is no strategy in the controller, or the strategy includes no digital inputs, the returned array will be empty.
     */
    public readDigitalInputs(): Promise<{ response: http.ClientResponse; body: Array<DigitalPointStateVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/digitalInputs';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<DigitalPointStateVar>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the specified digital output point&#39;s state (true &#x3D; on, false &#x3D; off)
     * @param ioName Name of the digit output point to read
     */
    public readDigitalOutputState(ioName: string): Promise<{ response: http.ClientResponse; body: DigitalPointStateObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/digitalOutputs/{ioName}/state'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is not null or undefined
        if (ioName === null || ioName === undefined) {
            throw new Error('Required parameter ioName was null or undefined when calling readDigitalOutputState.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DigitalPointStateObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name and state (true &#x3D; on, false &#x3D; off) of all digital output points in the strategy
     */
    public readDigitalOutputs(): Promise<{ response: http.ClientResponse; body: Array<DigitalPointStateVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/digitalOutputs';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<DigitalPointStateVar>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns current value of the specified down timer
     * @param downTimerName Name of the down timer variable to read
     */
    public readDownTimerValue(downTimerName: string): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/downTimers/{downTimerName}/value'
            .replace('{' + 'downTimerName' + '}', String(downTimerName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'downTimerName' is not null or undefined
        if (downTimerName === null || downTimerName === undefined) {
            throw new Error('Required parameter downTimerName was null or undefined when calling readDownTimerValue.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FloatValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name and current value of all down timers in the strategy
     */
    public readDownTimerVars(): Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/downTimers';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Read table elements
     * @param tableName Name of float table to read; starting index and number of elements may be specified (defaults to all elements)
     * @param startIndex Index of first element to read (default is 0)
     * @param numElements Number of elements to read (default is number of elements in the table minus startIndex)
     */
    public readFloatTable(tableName: string, startIndex?: number, numElements?: number): Promise<{ response: http.ClientResponse; body: Array<number>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/floats/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling readFloatTable.');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (numElements !== undefined) {
            queryParameters['numElements'] = numElements;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Read specified table element
     * @param tableName Name of float table to read
     * @param index Index of element to read
     */
    public readFloatTableElement(tableName: string, index: number): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/floats/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling readFloatTableElement.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling readFloatTableElement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FloatValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns an array of the name and length of all the float tables in the strategy
     */
    public readFloatTables(): Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/floats';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns value of the specified float variable
     * @param floatName Name of float variable to read
     */
    public readFloatVar(floatName: string): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/floats/{floatName}'
            .replace('{' + 'floatName' + '}', String(floatName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'floatName' is not null or undefined
        if (floatName === null || floatName === undefined) {
            throw new Error('Required parameter floatName was null or undefined when calling readFloatVar.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FloatValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name and value of all (single-precision) float variables in the strategy
     */
    public readFloatVars(): Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/floats';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Read a range of table elements from the specified integer32 table
     * @param tableName Name of integer32 table to read; starting index and number of elements may be specified (defaults to all elements)
     * @param startIndex Index of first element to read (default is 0)
     * @param numElements Number of elements to read (default is number of elements in the table minus startIndex)
     */
    public readInt32Table(tableName: string, startIndex?: number, numElements?: number): Promise<{ response: http.ClientResponse; body: Array<number>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int32s/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling readInt32Table.');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (numElements !== undefined) {
            queryParameters['numElements'] = numElements;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Read specified integer32 table element
     * @param tableName Name of the integer32 table to read
     * @param index Index of element to read
     */
    public readInt32TableElement(tableName: string, index: number): Promise<{ response: http.ClientResponse; body: Int32ValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int32s/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling readInt32TableElement.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling readInt32TableElement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Int32ValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns an array of the name and length of all the integer32 tables in the strategy
     */
    public readInt32Tables(): Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int32s';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns value of the specified integer32 variable
     * @param int32Name Name of integer32 variable to read
     */
    public readInt32Var(int32Name: string): Promise<{ response: http.ClientResponse; body: Int32ValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int32s/{int32Name}'
            .replace('{' + 'int32Name' + '}', String(int32Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int32Name' is not null or undefined
        if (int32Name === null || int32Name === undefined) {
            throw new Error('Required parameter int32Name was null or undefined when calling readInt32Var.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Int32ValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name and value of all integer32 variables in the strategy
     */
    public readInt32Vars(): Promise<{ response: http.ClientResponse; body: Array<Int32Var>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int32s';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Int32Var>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Read table elements
     * @param tableName Name of the integer64 table to read; starting index and number of elements may be specified (defaults to all elements)
     * @param startIndex Index of first element to read (default is 0)
     * @param numElements Number of elements to read (default is number of elements in the table minus startIndex)
     */
    public readInt64Table(tableName: string, startIndex?: number, numElements?: number): Promise<{ response: http.ClientResponse; body: Array<number>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling readInt64Table.');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (numElements !== undefined) {
            queryParameters['numElements'] = numElements;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Read table elements as strings
     * @param tableName Name of the integer64 table to read; starting index and number of elements may be specified (defaults to all elements)
     * @param startIndex Index of first element to read (default is 0)
     * @param numElements Number of elements to read (default is number of elements in the table minus startIndex)
     */
    public readInt64TableAsString(tableName: string, startIndex?: number, numElements?: number): Promise<{ response: http.ClientResponse; body: Array<string>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/_string'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling readInt64TableAsString.');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (numElements !== undefined) {
            queryParameters['numElements'] = numElements;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Read specified integer64 table element
     * @param tableName Name of integer64 table to read
     * @param index Index of element to read
     */
    public readInt64TableElement(tableName: string, index: number): Promise<{ response: http.ClientResponse; body: Int64ValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling readInt64TableElement.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling readInt64TableElement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Int64ValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Read specified integer64 table element as string
     * @param tableName Name of integer64 table to read
     * @param index Index of element to read
     */
    public readInt64TableElementAsString(tableName: string, index: number): Promise<{ response: http.ClientResponse; body: Int64StringValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/{index}/_string'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling readInt64TableElementAsString.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling readInt64TableElementAsString.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Int64StringValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns an array of the name and length of all the integer64 tables in the strategy
     */
    public readInt64Tables(): Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns value of the specified integer64 variable
     * @param int64Name Name of integer64 variable to read
     */
    public readInt64Var(int64Name: string): Promise<{ response: http.ClientResponse; body: Int64ValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s/{int64Name}'
            .replace('{' + 'int64Name' + '}', String(int64Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int64Name' is not null or undefined
        if (int64Name === null || int64Name === undefined) {
            throw new Error('Required parameter int64Name was null or undefined when calling readInt64Var.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Int64ValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns value of the specified integer64 variable as a string
     * @param int64Name Name of integer64 variable to read
     */
    public readInt64VarAsString(int64Name: string): Promise<{ response: http.ClientResponse; body: Int64StringValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s/{int64Name}/_string'
            .replace('{' + 'int64Name' + '}', String(int64Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int64Name' is not null or undefined
        if (int64Name === null || int64Name === undefined) {
            throw new Error('Required parameter int64Name was null or undefined when calling readInt64VarAsString.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Int64StringValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name and value of all integer64 variables in the strategy
     */
    public readInt64Vars(): Promise<{ response: http.ClientResponse; body: Array<Int64Var>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Int64Var>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name and value as a string of all integer64 variables in the strategy
     */
    public readInt64VarsAsStrings(): Promise<{ response: http.ClientResponse; body: Array<Int64VarAsString>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s/_string';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Int64VarAsString>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name, date, time, and CRC of the strategy currently in the controller, and the number of charts currently running. Empty strings and a 0 will be returned when there is no strategy.
     */
    public readStrategyDetails(): Promise<{ response: http.ClientResponse; body: StrategyResponse; }>
    {
        const localVarPath = this.basePath + '/device/strategy';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StrategyResponse; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Read table elements
     * @param tableName Name of string table to read; starting index and number of elements may be specified (defaults to all elements)
     * @param startIndex Index of first element to read (default is 0)
     * @param numElements Number of elements to read (default is number of elements in the table minus startIndex)
     */
    public readStringTable(tableName: string, startIndex?: number, numElements?: number): Promise<{ response: http.ClientResponse; body: Array<string>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/strings/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling readStringTable.');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (numElements !== undefined) {
            queryParameters['numElements'] = numElements;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Read specified table element
     * @param tableName Name of string table to read
     * @param index Index of element to read
     */
    public readStringTableElement(tableName: string, index: number): Promise<{ response: http.ClientResponse; body: StringValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/strings/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling readStringTableElement.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling readStringTableElement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StringValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns an array of the name and length of all the string tables in the strategy
     */
    public readStringTables(): Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/strings';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns value of the specified string
     * @param stringName Name of string variable to read
     */
    public readStringVar(stringName: string): Promise<{ response: http.ClientResponse; body: StringValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/strings/{stringName}'
            .replace('{' + 'stringName' + '}', String(stringName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stringName' is not null or undefined
        if (stringName === null || stringName === undefined) {
            throw new Error('Required parameter stringName was null or undefined when calling readStringVar.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StringValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name and value of all string variables in the strategy
     */
    public readStringVars(): Promise<{ response: http.ClientResponse; body: Array<StringVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/strings';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<StringVar>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns current value of the specified up timer
     * @param upTimerName Name of the up timer variable to read
     */
    public readUpTimerValue(upTimerName: string): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/upTimers/{upTimerName}/value'
            .replace('{' + 'upTimerName' + '}', String(upTimerName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'upTimerName' is not null or undefined
        if (upTimerName === null || upTimerName === undefined) {
            throw new Error('Required parameter upTimerName was null or undefined when calling readUpTimerValue.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FloatValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name and current value of all up timers in the strategy
     */
    public readUpTimerVars(): Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/upTimers';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Sets the value of the specified analog output point
     * @param ioName Name of the analog output point to write
     * @param body Value to write
     */
    public writeAnalogOutputEu(ioName: string, body: FloatValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/analogOutputs/{ioName}/eu'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is not null or undefined
        if (ioName === null || ioName === undefined) {
            throw new Error('Required parameter ioName was null or undefined when calling writeAnalogOutputEu.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling writeAnalogOutputEu.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Sets the value of the specified digital output point
     * @param ioName Name of the digital output point to write
     * @param body Value to write
     */
    public writeDigitalOutputState(ioName: string, body: DigitalPointStateObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/digitalOutputs/{ioName}/state'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is not null or undefined
        if (ioName === null || ioName === undefined) {
            throw new Error('Required parameter ioName was null or undefined when calling writeDigitalOutputState.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling writeDigitalOutputState.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Write table elements
     * @param tableName Name of float table to write; starting index may be specified
     * @param floatArray Array of element values to write starting at startIndex
     * @param startIndex Index of first element to write (default is 0)
     */
    public writeFloatTable(tableName: string, floatArray: Array<number>, startIndex?: number): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/floats/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling writeFloatTable.');
        }

        // verify required parameter 'floatArray' is not null or undefined
        if (floatArray === null || floatArray === undefined) {
            throw new Error('Required parameter floatArray was null or undefined when calling writeFloatTable.');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: floatArray,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Write specified table element
     * @param tableName Name of float table to write
     * @param index Index of element to write
     * @param floatElementObject Element to write starting at index
     */
    public writeFloatTableElement(tableName: string, index: number, floatElementObject: FloatValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/floats/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling writeFloatTableElement.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling writeFloatTableElement.');
        }

        // verify required parameter 'floatElementObject' is not null or undefined
        if (floatElementObject === null || floatElementObject === undefined) {
            throw new Error('Required parameter floatElementObject was null or undefined when calling writeFloatTableElement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: floatElementObject,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Sets the value of a float variable
     * @param floatName Name of the float variable to write
     * @param body Value to write to the float variable
     */
    public writeFloatVar(floatName: string, body: FloatValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/floats/{floatName}'
            .replace('{' + 'floatName' + '}', String(floatName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'floatName' is not null or undefined
        if (floatName === null || floatName === undefined) {
            throw new Error('Required parameter floatName was null or undefined when calling writeFloatVar.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling writeFloatVar.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Write a range of table elements
     * @param tableName Name of integer32 table to write; starting index may be specified
     * @param int32Array Array of element values to write starting at startIndex; if the list of elements is too long to fit in the specified table, extra elements will be ignored
     * @param startIndex Index of first element to write (default is 0)
     */
    public writeInt32Table(tableName: string, int32Array: Array<number>, startIndex?: number): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int32s/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling writeInt32Table.');
        }

        // verify required parameter 'int32Array' is not null or undefined
        if (int32Array === null || int32Array === undefined) {
            throw new Error('Required parameter int32Array was null or undefined when calling writeInt32Table.');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: int32Array,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Write specified integer32 table element
     * @param tableName Name of the integer32 table to write
     * @param index Index of element to write
     * @param int32ElementObject Element to write at index specified
     */
    public writeInt32TableElement(tableName: string, index: number, int32ElementObject: Int32ValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int32s/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling writeInt32TableElement.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling writeInt32TableElement.');
        }

        // verify required parameter 'int32ElementObject' is not null or undefined
        if (int32ElementObject === null || int32ElementObject === undefined) {
            throw new Error('Required parameter int32ElementObject was null or undefined when calling writeInt32TableElement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: int32ElementObject,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Sets the value of an integer32 variable
     * @param int32Name Name of integer32 variable to write
     * @param body Value to write to the integer32 variable
     */
    public writeInt32Var(int32Name: string, body: Int32ValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int32s/{int32Name}'
            .replace('{' + 'int32Name' + '}', String(int32Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int32Name' is not null or undefined
        if (int32Name === null || int32Name === undefined) {
            throw new Error('Required parameter int32Name was null or undefined when calling writeInt32Var.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling writeInt32Var.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Write table elements
     * @param tableName Name of integer64 table to write; starting index may be specified
     * @param int64Array Array of element values to write starting at startIndex; if the array of elements is too long to fit in the specified table, extra elements will be ignored
     * @param startIndex Index of first element to write; default is 0
     */
    public writeInt64Table(tableName: string, int64Array: Array<number>, startIndex?: number): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling writeInt64Table.');
        }

        // verify required parameter 'int64Array' is not null or undefined
        if (int64Array === null || int64Array === undefined) {
            throw new Error('Required parameter int64Array was null or undefined when calling writeInt64Table.');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: int64Array,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Write table elements as strings
     * @param tableName Name of integer64 table to write; starting index may be specified
     * @param int64AsStringArray Array of element values to write starting at startIndex; if the array of elements is too long to fit in the specified table, extra elements will be ignored
     * @param startIndex Index of first element to write; default is 0.
     */
    public writeInt64TableAsString(tableName: string, int64AsStringArray: Array<string>, startIndex?: number): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/_string'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling writeInt64TableAsString.');
        }

        // verify required parameter 'int64AsStringArray' is not null or undefined
        if (int64AsStringArray === null || int64AsStringArray === undefined) {
            throw new Error('Required parameter int64AsStringArray was null or undefined when calling writeInt64TableAsString.');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: int64AsStringArray,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Write specified integer64 table element
     * @param tableName Name of the integer64 table to write
     * @param index Index of element to write
     * @param int64ElementObject Element to write starting at index specified
     */
    public writeInt64TableElement(tableName: string, index: number, int64ElementObject: Int64ValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling writeInt64TableElement.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling writeInt64TableElement.');
        }

        // verify required parameter 'int64ElementObject' is not null or undefined
        if (int64ElementObject === null || int64ElementObject === undefined) {
            throw new Error('Required parameter int64ElementObject was null or undefined when calling writeInt64TableElement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: int64ElementObject,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Write specified integer64 table element as string
     * @param tableName Name of the integer64 table to write
     * @param index Index of element to write
     * @param int64ElementObject Element to write starting at index specified
     */
    public writeInt64TableElementAsString(tableName: string, index: number, int64ElementObject: Int64StringValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/{index}/_string'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling writeInt64TableElementAsString.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling writeInt64TableElementAsString.');
        }

        // verify required parameter 'int64ElementObject' is not null or undefined
        if (int64ElementObject === null || int64ElementObject === undefined) {
            throw new Error('Required parameter int64ElementObject was null or undefined when calling writeInt64TableElementAsString.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: int64ElementObject,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Sets the value of an integer64 variable
     * @param int64Name Name of integer64 variable to write
     * @param body Value to write to the integer64 variable
     */
    public writeInt64Var(int64Name: string, body: Int64ValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s/{int64Name}'
            .replace('{' + 'int64Name' + '}', String(int64Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int64Name' is not null or undefined
        if (int64Name === null || int64Name === undefined) {
            throw new Error('Required parameter int64Name was null or undefined when calling writeInt64Var.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling writeInt64Var.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Sets the value of an integer64 variable as a string
     * @param int64Name Name of integer64 variable to write
     * @param body Value to write to the integer64 variable
     */
    public writeInt64VarAsString(int64Name: string, body: Int64StringValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s/{int64Name}/_string'
            .replace('{' + 'int64Name' + '}', String(int64Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int64Name' is not null or undefined
        if (int64Name === null || int64Name === undefined) {
            throw new Error('Required parameter int64Name was null or undefined when calling writeInt64VarAsString.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling writeInt64VarAsString.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Write table elements
     * @param tableName Name of string table to write; starting index may be specified
     * @param stringArray Array of element values to write starting at startIndex; if an element value is longer than the string width, the string will be truncated to fit
     * @param startIndex Index of first element to write (default is 0)
     */
    public writeStringTable(tableName: string, stringArray: Array<string>, startIndex?: number): Promise<{ response: http.ClientResponse; body: ErrorResponse200OKish; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/strings/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling writeStringTable.');
        }

        // verify required parameter 'stringArray' is not null or undefined
        if (stringArray === null || stringArray === undefined) {
            throw new Error('Required parameter stringArray was null or undefined when calling writeStringTable.');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: stringArray,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ErrorResponse200OKish; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Write specified table element
     * @param tableName Name of string table to write
     * @param index Index of element to write
     * @param stringElementObject Element to write starting at index
     */
    public writeStringTableElement(tableName: string, index: number, stringElementObject: StringValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/strings/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling writeStringTableElement.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling writeStringTableElement.');
        }

        // verify required parameter 'stringElementObject' is not null or undefined
        if (stringElementObject === null || stringElementObject === undefined) {
            throw new Error('Required parameter stringElementObject was null or undefined when calling writeStringTableElement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: stringElementObject,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Sets the value of a string variable
     * @param stringName Name of string variable to write
     * @param body String to write. If the value is longer than the string width, the string will be truncated to fit.
     */
    public writeStringVar(stringName: string, body: StringValueObject): Promise<{ response: http.ClientResponse; body: ErrorResponse200OKish; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/strings/{stringName}'
            .replace('{' + 'stringName' + '}', String(stringName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stringName' is not null or undefined
        if (stringName === null || stringName === undefined) {
            throw new Error('Required parameter stringName was null or undefined when calling writeStringVar.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling writeStringVar.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ErrorResponse200OKish; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DeviceApiApiKeys
{
}

export class DeviceApi
{
    protected basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string)
    {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean)
    {
        this._useQuerystring = value;
    }

    public setApiKey(key: DeviceApiApiKeys, value: string)
    {
        this.authentications[DeviceApiApiKeys[key]].apiKey = value;
    }
    set username(username: string)
    {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string)
    {
        this.authentications.basicAuth.password = password;
    }
    private extendObj<T1, T2>(objA: T1, objB: T2)
    {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return <T1 & T2>objA;
    }
    /**
     * 
     * Returns controller&#39;s type, e.g. \&quot;SNAP-PAC-R1\&quot;; firmware version; both mac addresses; and uptime in seconds
     */
    public readDeviceDetails(): Promise<{ response: http.ClientResponse; body: ControllerResponse; }>
    {
        const localVarPath = this.basePath + '/device';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ControllerResponse; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum IosApiApiKeys
{
}

export class IosApi
{
    protected basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string)
    {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean)
    {
        this._useQuerystring = value;
    }

    public setApiKey(key: IosApiApiKeys, value: string)
    {
        this.authentications[IosApiApiKeys[key]].apiKey = value;
    }
    set username(username: string)
    {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string)
    {
        this.authentications.basicAuth.password = password;
    }
    private extendObj<T1, T2>(objA: T1, objB: T2)
    {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return <T1 & T2>objA;
    }
    /**
     * 
     * Reads the value in engineering units (EU) of the specified analog input
     * @param ioName Name of the analog input point to read
     */
    public readAnalogInputEu(ioName: string): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/analogInputs/{ioName}/eu'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is not null or undefined
        if (ioName === null || ioName === undefined) {
            throw new Error('Required parameter ioName was null or undefined when calling readAnalogInputEu.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FloatValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name and engineering units (EU) for all analog input points in the strategy
     */
    public readAnalogInputs(): Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/analogInputs';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Reads the value in engineering units (EU) of the specified analog output
     * @param ioName Name of analog output point to read
     */
    public readAnalogOutputEu(ioName: string): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/analogOutputs/{ioName}/eu'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is not null or undefined
        if (ioName === null || ioName === undefined) {
            throw new Error('Required parameter ioName was null or undefined when calling readAnalogOutputEu.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FloatValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name and engineering units (EU) for all analog output points in the strategy
     */
    public readAnalogOutputs(): Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/analogOutputs';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the specified digital input point&#39;s state (true &#x3D; on, false &#x3D; off)
     * @param ioName Name of the digital input point to read
     */
    public readDigitalInputState(ioName: string): Promise<{ response: http.ClientResponse; body: DigitalPointStateObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/digitalInputs/{ioName}/state'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is not null or undefined
        if (ioName === null || ioName === undefined) {
            throw new Error('Required parameter ioName was null or undefined when calling readDigitalInputState.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DigitalPointStateObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name and state (true &#x3D; on, false &#x3D; off) of all digital input points in the strategy. If there is no strategy in the controller, or the strategy includes no digital inputs, the returned array will be empty.
     */
    public readDigitalInputs(): Promise<{ response: http.ClientResponse; body: Array<DigitalPointStateVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/digitalInputs';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<DigitalPointStateVar>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the specified digital output point&#39;s state (true &#x3D; on, false &#x3D; off)
     * @param ioName Name of the digit output point to read
     */
    public readDigitalOutputState(ioName: string): Promise<{ response: http.ClientResponse; body: DigitalPointStateObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/digitalOutputs/{ioName}/state'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is not null or undefined
        if (ioName === null || ioName === undefined) {
            throw new Error('Required parameter ioName was null or undefined when calling readDigitalOutputState.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DigitalPointStateObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name and state (true &#x3D; on, false &#x3D; off) of all digital output points in the strategy
     */
    public readDigitalOutputs(): Promise<{ response: http.ClientResponse; body: Array<DigitalPointStateVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/digitalOutputs';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<DigitalPointStateVar>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Sets the value of the specified analog output point
     * @param ioName Name of the analog output point to write
     * @param body Value to write
     */
    public writeAnalogOutputEu(ioName: string, body: FloatValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/analogOutputs/{ioName}/eu'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is not null or undefined
        if (ioName === null || ioName === undefined) {
            throw new Error('Required parameter ioName was null or undefined when calling writeAnalogOutputEu.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling writeAnalogOutputEu.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Sets the value of the specified digital output point
     * @param ioName Name of the digital output point to write
     * @param body Value to write
     */
    public writeDigitalOutputState(ioName: string, body: DigitalPointStateObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/ios/digitalOutputs/{ioName}/state'
            .replace('{' + 'ioName' + '}', String(ioName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ioName' is not null or undefined
        if (ioName === null || ioName === undefined) {
            throw new Error('Required parameter ioName was null or undefined when calling writeDigitalOutputState.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling writeDigitalOutputState.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StrategyApiApiKeys
{
}

export class StrategyApi
{
    protected basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string)
    {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean)
    {
        this._useQuerystring = value;
    }

    public setApiKey(key: StrategyApiApiKeys, value: string)
    {
        this.authentications[StrategyApiApiKeys[key]].apiKey = value;
    }
    set username(username: string)
    {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string)
    {
        this.authentications.basicAuth.password = password;
    }
    private extendObj<T1, T2>(objA: T1, objB: T2)
    {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return <T1 & T2>objA;
    }
    /**
     * 
     * Returns the name, date, time, and CRC of the strategy currently in the controller, and the number of charts currently running. Empty strings and a 0 will be returned when there is no strategy.
     */
    public readStrategyDetails(): Promise<{ response: http.ClientResponse; body: StrategyResponse; }>
    {
        const localVarPath = this.basePath + '/device/strategy';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StrategyResponse; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TablesApiApiKeys
{
}

export class TablesApi
{
    protected basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string)
    {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean)
    {
        this._useQuerystring = value;
    }

    public setApiKey(key: TablesApiApiKeys, value: string)
    {
        this.authentications[TablesApiApiKeys[key]].apiKey = value;
    }
    set username(username: string)
    {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string)
    {
        this.authentications.basicAuth.password = password;
    }
    private extendObj<T1, T2>(objA: T1, objB: T2)
    {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return <T1 & T2>objA;
    }
    /**
     * 
     * Read table elements
     * @param tableName Name of float table to read; starting index and number of elements may be specified (defaults to all elements)
     * @param startIndex Index of first element to read (default is 0)
     * @param numElements Number of elements to read (default is number of elements in the table minus startIndex)
     */
    public readFloatTable(tableName: string, startIndex?: number, numElements?: number): Promise<{ response: http.ClientResponse; body: Array<number>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/floats/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling readFloatTable.');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (numElements !== undefined) {
            queryParameters['numElements'] = numElements;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Read specified table element
     * @param tableName Name of float table to read
     * @param index Index of element to read
     */
    public readFloatTableElement(tableName: string, index: number): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/floats/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling readFloatTableElement.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling readFloatTableElement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FloatValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns an array of the name and length of all the float tables in the strategy
     */
    public readFloatTables(): Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/floats';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Read a range of table elements from the specified integer32 table
     * @param tableName Name of integer32 table to read; starting index and number of elements may be specified (defaults to all elements)
     * @param startIndex Index of first element to read (default is 0)
     * @param numElements Number of elements to read (default is number of elements in the table minus startIndex)
     */
    public readInt32Table(tableName: string, startIndex?: number, numElements?: number): Promise<{ response: http.ClientResponse; body: Array<number>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int32s/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling readInt32Table.');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (numElements !== undefined) {
            queryParameters['numElements'] = numElements;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Read specified integer32 table element
     * @param tableName Name of the integer32 table to read
     * @param index Index of element to read
     */
    public readInt32TableElement(tableName: string, index: number): Promise<{ response: http.ClientResponse; body: Int32ValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int32s/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling readInt32TableElement.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling readInt32TableElement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Int32ValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns an array of the name and length of all the integer32 tables in the strategy
     */
    public readInt32Tables(): Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int32s';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Read table elements
     * @param tableName Name of the integer64 table to read; starting index and number of elements may be specified (defaults to all elements)
     * @param startIndex Index of first element to read (default is 0)
     * @param numElements Number of elements to read (default is number of elements in the table minus startIndex)
     */
    public readInt64Table(tableName: string, startIndex?: number, numElements?: number): Promise<{ response: http.ClientResponse; body: Array<number>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling readInt64Table.');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (numElements !== undefined) {
            queryParameters['numElements'] = numElements;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<number>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Read table elements as strings
     * @param tableName Name of the integer64 table to read; starting index and number of elements may be specified (defaults to all elements)
     * @param startIndex Index of first element to read (default is 0)
     * @param numElements Number of elements to read (default is number of elements in the table minus startIndex)
     */
    public readInt64TableAsString(tableName: string, startIndex?: number, numElements?: number): Promise<{ response: http.ClientResponse; body: Array<string>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/_string'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling readInt64TableAsString.');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (numElements !== undefined) {
            queryParameters['numElements'] = numElements;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Read specified integer64 table element
     * @param tableName Name of integer64 table to read
     * @param index Index of element to read
     */
    public readInt64TableElement(tableName: string, index: number): Promise<{ response: http.ClientResponse; body: Int64ValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling readInt64TableElement.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling readInt64TableElement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Int64ValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Read specified integer64 table element as string
     * @param tableName Name of integer64 table to read
     * @param index Index of element to read
     */
    public readInt64TableElementAsString(tableName: string, index: number): Promise<{ response: http.ClientResponse; body: Int64StringValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/{index}/_string'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling readInt64TableElementAsString.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling readInt64TableElementAsString.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Int64StringValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns an array of the name and length of all the integer64 tables in the strategy
     */
    public readInt64Tables(): Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Read table elements
     * @param tableName Name of string table to read; starting index and number of elements may be specified (defaults to all elements)
     * @param startIndex Index of first element to read (default is 0)
     * @param numElements Number of elements to read (default is number of elements in the table minus startIndex)
     */
    public readStringTable(tableName: string, startIndex?: number, numElements?: number): Promise<{ response: http.ClientResponse; body: Array<string>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/strings/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling readStringTable.');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (numElements !== undefined) {
            queryParameters['numElements'] = numElements;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Read specified table element
     * @param tableName Name of string table to read
     * @param index Index of element to read
     */
    public readStringTableElement(tableName: string, index: number): Promise<{ response: http.ClientResponse; body: StringValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/strings/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling readStringTableElement.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling readStringTableElement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StringValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns an array of the name and length of all the string tables in the strategy
     */
    public readStringTables(): Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/strings';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<TableDef>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Write table elements
     * @param tableName Name of float table to write; starting index may be specified
     * @param floatArray Array of element values to write starting at startIndex
     * @param startIndex Index of first element to write (default is 0)
     */
    public writeFloatTable(tableName: string, floatArray: Array<number>, startIndex?: number): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/floats/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling writeFloatTable.');
        }

        // verify required parameter 'floatArray' is not null or undefined
        if (floatArray === null || floatArray === undefined) {
            throw new Error('Required parameter floatArray was null or undefined when calling writeFloatTable.');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: floatArray,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Write specified table element
     * @param tableName Name of float table to write
     * @param index Index of element to write
     * @param floatElementObject Element to write starting at index
     */
    public writeFloatTableElement(tableName: string, index: number, floatElementObject: FloatValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/floats/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling writeFloatTableElement.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling writeFloatTableElement.');
        }

        // verify required parameter 'floatElementObject' is not null or undefined
        if (floatElementObject === null || floatElementObject === undefined) {
            throw new Error('Required parameter floatElementObject was null or undefined when calling writeFloatTableElement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: floatElementObject,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Write a range of table elements
     * @param tableName Name of integer32 table to write; starting index may be specified
     * @param int32Array Array of element values to write starting at startIndex; if the list of elements is too long to fit in the specified table, extra elements will be ignored
     * @param startIndex Index of first element to write (default is 0)
     */
    public writeInt32Table(tableName: string, int32Array: Array<number>, startIndex?: number): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int32s/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling writeInt32Table.');
        }

        // verify required parameter 'int32Array' is not null or undefined
        if (int32Array === null || int32Array === undefined) {
            throw new Error('Required parameter int32Array was null or undefined when calling writeInt32Table.');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: int32Array,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Write specified integer32 table element
     * @param tableName Name of the integer32 table to write
     * @param index Index of element to write
     * @param int32ElementObject Element to write at index specified
     */
    public writeInt32TableElement(tableName: string, index: number, int32ElementObject: Int32ValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int32s/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling writeInt32TableElement.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling writeInt32TableElement.');
        }

        // verify required parameter 'int32ElementObject' is not null or undefined
        if (int32ElementObject === null || int32ElementObject === undefined) {
            throw new Error('Required parameter int32ElementObject was null or undefined when calling writeInt32TableElement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: int32ElementObject,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Write table elements
     * @param tableName Name of integer64 table to write; starting index may be specified
     * @param int64Array Array of element values to write starting at startIndex; if the array of elements is too long to fit in the specified table, extra elements will be ignored
     * @param startIndex Index of first element to write; default is 0
     */
    public writeInt64Table(tableName: string, int64Array: Array<number>, startIndex?: number): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling writeInt64Table.');
        }

        // verify required parameter 'int64Array' is not null or undefined
        if (int64Array === null || int64Array === undefined) {
            throw new Error('Required parameter int64Array was null or undefined when calling writeInt64Table.');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: int64Array,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Write table elements as strings
     * @param tableName Name of integer64 table to write; starting index may be specified
     * @param int64AsStringArray Array of element values to write starting at startIndex; if the array of elements is too long to fit in the specified table, extra elements will be ignored
     * @param startIndex Index of first element to write; default is 0.
     */
    public writeInt64TableAsString(tableName: string, int64AsStringArray: Array<string>, startIndex?: number): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/_string'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling writeInt64TableAsString.');
        }

        // verify required parameter 'int64AsStringArray' is not null or undefined
        if (int64AsStringArray === null || int64AsStringArray === undefined) {
            throw new Error('Required parameter int64AsStringArray was null or undefined when calling writeInt64TableAsString.');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: int64AsStringArray,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Write specified integer64 table element
     * @param tableName Name of the integer64 table to write
     * @param index Index of element to write
     * @param int64ElementObject Element to write starting at index specified
     */
    public writeInt64TableElement(tableName: string, index: number, int64ElementObject: Int64ValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling writeInt64TableElement.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling writeInt64TableElement.');
        }

        // verify required parameter 'int64ElementObject' is not null or undefined
        if (int64ElementObject === null || int64ElementObject === undefined) {
            throw new Error('Required parameter int64ElementObject was null or undefined when calling writeInt64TableElement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: int64ElementObject,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Write specified integer64 table element as string
     * @param tableName Name of the integer64 table to write
     * @param index Index of element to write
     * @param int64ElementObject Element to write starting at index specified
     */
    public writeInt64TableElementAsString(tableName: string, index: number, int64ElementObject: Int64StringValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/int64s/{tableName}/{index}/_string'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling writeInt64TableElementAsString.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling writeInt64TableElementAsString.');
        }

        // verify required parameter 'int64ElementObject' is not null or undefined
        if (int64ElementObject === null || int64ElementObject === undefined) {
            throw new Error('Required parameter int64ElementObject was null or undefined when calling writeInt64TableElementAsString.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: int64ElementObject,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Write table elements
     * @param tableName Name of string table to write; starting index may be specified
     * @param stringArray Array of element values to write starting at startIndex; if an element value is longer than the string width, the string will be truncated to fit
     * @param startIndex Index of first element to write (default is 0)
     */
    public writeStringTable(tableName: string, stringArray: Array<string>, startIndex?: number): Promise<{ response: http.ClientResponse; body: ErrorResponse200OKish; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/strings/{tableName}'
            .replace('{' + 'tableName' + '}', String(tableName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling writeStringTable.');
        }

        // verify required parameter 'stringArray' is not null or undefined
        if (stringArray === null || stringArray === undefined) {
            throw new Error('Required parameter stringArray was null or undefined when calling writeStringTable.');
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: stringArray,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ErrorResponse200OKish; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Write specified table element
     * @param tableName Name of string table to write
     * @param index Index of element to write
     * @param stringElementObject Element to write starting at index
     */
    public writeStringTableElement(tableName: string, index: number, stringElementObject: StringValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/tables/strings/{tableName}/{index}'
            .replace('{' + 'tableName' + '}', String(tableName))
            .replace('{' + 'index' + '}', String(index));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'tableName' is not null or undefined
        if (tableName === null || tableName === undefined) {
            throw new Error('Required parameter tableName was null or undefined when calling writeStringTableElement.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling writeStringTableElement.');
        }

        // verify required parameter 'stringElementObject' is not null or undefined
        if (stringElementObject === null || stringElementObject === undefined) {
            throw new Error('Required parameter stringElementObject was null or undefined when calling writeStringTableElement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: stringElementObject,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VarsApiApiKeys
{
}

export class VarsApi
{
    protected basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string)
    {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean)
    {
        this._useQuerystring = value;
    }

    public setApiKey(key: VarsApiApiKeys, value: string)
    {
        this.authentications[VarsApiApiKeys[key]].apiKey = value;
    }
    set username(username: string)
    {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string)
    {
        this.authentications.basicAuth.password = password;
    }
    private extendObj<T1, T2>(objA: T1, objB: T2)
    {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return <T1 & T2>objA;
    }
    /**
     * 
     * Returns current value of the specified down timer
     * @param downTimerName Name of the down timer variable to read
     */
    public readDownTimerValue(downTimerName: string): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/downTimers/{downTimerName}/value'
            .replace('{' + 'downTimerName' + '}', String(downTimerName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'downTimerName' is not null or undefined
        if (downTimerName === null || downTimerName === undefined) {
            throw new Error('Required parameter downTimerName was null or undefined when calling readDownTimerValue.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FloatValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name and current value of all down timers in the strategy
     */
    public readDownTimerVars(): Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/downTimers';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns value of the specified float variable
     * @param floatName Name of float variable to read
     */
    public readFloatVar(floatName: string): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/floats/{floatName}'
            .replace('{' + 'floatName' + '}', String(floatName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'floatName' is not null or undefined
        if (floatName === null || floatName === undefined) {
            throw new Error('Required parameter floatName was null or undefined when calling readFloatVar.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FloatValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name and value of all (single-precision) float variables in the strategy
     */
    public readFloatVars(): Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/floats';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns value of the specified integer32 variable
     * @param int32Name Name of integer32 variable to read
     */
    public readInt32Var(int32Name: string): Promise<{ response: http.ClientResponse; body: Int32ValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int32s/{int32Name}'
            .replace('{' + 'int32Name' + '}', String(int32Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int32Name' is not null or undefined
        if (int32Name === null || int32Name === undefined) {
            throw new Error('Required parameter int32Name was null or undefined when calling readInt32Var.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Int32ValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name and value of all integer32 variables in the strategy
     */
    public readInt32Vars(): Promise<{ response: http.ClientResponse; body: Array<Int32Var>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int32s';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Int32Var>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns value of the specified integer64 variable
     * @param int64Name Name of integer64 variable to read
     */
    public readInt64Var(int64Name: string): Promise<{ response: http.ClientResponse; body: Int64ValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s/{int64Name}'
            .replace('{' + 'int64Name' + '}', String(int64Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int64Name' is not null or undefined
        if (int64Name === null || int64Name === undefined) {
            throw new Error('Required parameter int64Name was null or undefined when calling readInt64Var.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Int64ValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns value of the specified integer64 variable as a string
     * @param int64Name Name of integer64 variable to read
     */
    public readInt64VarAsString(int64Name: string): Promise<{ response: http.ClientResponse; body: Int64StringValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s/{int64Name}/_string'
            .replace('{' + 'int64Name' + '}', String(int64Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int64Name' is not null or undefined
        if (int64Name === null || int64Name === undefined) {
            throw new Error('Required parameter int64Name was null or undefined when calling readInt64VarAsString.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Int64StringValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name and value of all integer64 variables in the strategy
     */
    public readInt64Vars(): Promise<{ response: http.ClientResponse; body: Array<Int64Var>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Int64Var>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name and value as a string of all integer64 variables in the strategy
     */
    public readInt64VarsAsStrings(): Promise<{ response: http.ClientResponse; body: Array<Int64VarAsString>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s/_string';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Int64VarAsString>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns value of the specified string
     * @param stringName Name of string variable to read
     */
    public readStringVar(stringName: string): Promise<{ response: http.ClientResponse; body: StringValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/strings/{stringName}'
            .replace('{' + 'stringName' + '}', String(stringName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stringName' is not null or undefined
        if (stringName === null || stringName === undefined) {
            throw new Error('Required parameter stringName was null or undefined when calling readStringVar.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StringValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name and value of all string variables in the strategy
     */
    public readStringVars(): Promise<{ response: http.ClientResponse; body: Array<StringVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/strings';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<StringVar>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns current value of the specified up timer
     * @param upTimerName Name of the up timer variable to read
     */
    public readUpTimerValue(upTimerName: string): Promise<{ response: http.ClientResponse; body: FloatValueObject; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/upTimers/{upTimerName}/value'
            .replace('{' + 'upTimerName' + '}', String(upTimerName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'upTimerName' is not null or undefined
        if (upTimerName === null || upTimerName === undefined) {
            throw new Error('Required parameter upTimerName was null or undefined when calling readUpTimerValue.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FloatValueObject; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Returns the name and current value of all up timers in the strategy
     */
    public readUpTimerVars(): Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/upTimers';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<FloatVar>; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Sets the value of a float variable
     * @param floatName Name of the float variable to write
     * @param body Value to write to the float variable
     */
    public writeFloatVar(floatName: string, body: FloatValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/floats/{floatName}'
            .replace('{' + 'floatName' + '}', String(floatName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'floatName' is not null or undefined
        if (floatName === null || floatName === undefined) {
            throw new Error('Required parameter floatName was null or undefined when calling writeFloatVar.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling writeFloatVar.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Sets the value of an integer32 variable
     * @param int32Name Name of integer32 variable to write
     * @param body Value to write to the integer32 variable
     */
    public writeInt32Var(int32Name: string, body: Int32ValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int32s/{int32Name}'
            .replace('{' + 'int32Name' + '}', String(int32Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int32Name' is not null or undefined
        if (int32Name === null || int32Name === undefined) {
            throw new Error('Required parameter int32Name was null or undefined when calling writeInt32Var.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling writeInt32Var.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Sets the value of an integer64 variable
     * @param int64Name Name of integer64 variable to write
     * @param body Value to write to the integer64 variable
     */
    public writeInt64Var(int64Name: string, body: Int64ValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s/{int64Name}'
            .replace('{' + 'int64Name' + '}', String(int64Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int64Name' is not null or undefined
        if (int64Name === null || int64Name === undefined) {
            throw new Error('Required parameter int64Name was null or undefined when calling writeInt64Var.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling writeInt64Var.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Sets the value of an integer64 variable as a string
     * @param int64Name Name of integer64 variable to write
     * @param body Value to write to the integer64 variable
     */
    public writeInt64VarAsString(int64Name: string, body: Int64StringValueObject): Promise<{ response: http.ClientResponse; body?: any; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/int64s/{int64Name}/_string'
            .replace('{' + 'int64Name' + '}', String(int64Name));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'int64Name' is not null or undefined
        if (int64Name === null || int64Name === undefined) {
            throw new Error('Required parameter int64Name was null or undefined when calling writeInt64VarAsString.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling writeInt64VarAsString.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Sets the value of a string variable
     * @param stringName Name of string variable to write
     * @param body String to write. If the value is longer than the string width, the string will be truncated to fit.
     */
    public writeStringVar(stringName: string, body: StringValueObject): Promise<{ response: http.ClientResponse; body: ErrorResponse200OKish; }>
    {
        const localVarPath = this.basePath + '/device/strategy/vars/strings/{stringName}'
            .replace('{' + 'stringName' + '}', String(stringName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stringName' is not null or undefined
        if (stringName === null || stringName === undefined) {
            throw new Error('Required parameter stringName was null or undefined when calling writeStringVar.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling writeStringVar.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ErrorResponse200OKish; }>((resolve, reject) =>
        {
            request(requestOptions, (error, response, body) =>
            {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
